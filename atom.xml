<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mojito</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-27T02:55:45.390Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mojito</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Promise解读</title>
    <link href="http://yoursite.com/2018/08/19/promise/"/>
    <id>http://yoursite.com/2018/08/19/promise/</id>
    <published>2018-08-19T08:27:23.000Z</published>
    <updated>2018-09-27T02:55:45.390Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最近看的一些零碎片段</strong><br><a id="more"></a><br>下面是最核心的两段代码：Promise的构造函数，和then方法的定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Promises must be constructed via new'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Promise constructor\'s argument is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._deferredState = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>._state = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>._value = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._deferreds = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (fn === noop) <span class="keyword">return</span>;</span><br><span class="line">  doResolve(fn, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>._onHandle = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">Promise</span>._onReject = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">Promise</span>._noop = noop;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.constructor !== <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> safeThen(<span class="keyword">this</span>, onFulfilled, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Promise</span>(noop);</span><br><span class="line">  handle(<span class="keyword">this</span>, <span class="keyword">new</span> Handler(onFulfilled, onRejected, res));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><p>其中我们可以看到then方法中的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Promise</span>(noop);</span><br><span class="line">handle(<span class="keyword">this</span>, <span class="keyword">new</span> Handler(onFulfilled, onRejected, res));</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p><p>这三行代码就说明了Promise的每一次then方法都会重新构造一个Promise对象，而不是在原有对象上修改。为了证明这一点，我写了一个小demo:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = promise</span><br><span class="line"><span class="keyword">var</span> b = promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a === b ) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//证明我们的猜想是正确的</span></span><br></pre></td></tr></table></figure></p><p>我觉得设计者这么做是因为Promise的定义，在阮一峰的相关文档中，我们可以看到</p><ul><li>Promise对象有以下两个特点。（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ul><p><strong>因为在Promise定义的回调函数是可以返回另一个Promise的，如果不新构造一个对象，那么将改变原有Promise对象的状态，这是和定义想反的。（当然这只是我的一个猜想。）</strong></p><hr><p>在这里不便把所有源码都展开但是可以将then函数调用其他函数的大概流程图画一下<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">then--&gt;handle</span><br><span class="line">handle--&gt;handleResovled</span><br><span class="line">handleResovled--&gt;resolve</span><br></pre></td></tr></table></figure></p><hr><p>handle函数的大概作用就是根据Promise对象回调函数的返回值，修改当前Promise对象，其中有一行关键的代码<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (self._state === <span class="number">3</span>) &#123;</span><br><span class="line">    self = self._value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p> self代表当前Promise对象，而State === 3 代表着当前Promise对象回调函数返回值是一个Promise对象，在这里作者直接将当前Promise对象，替换成了回调函数返回的新Promise进行后续操作。</p><hr><p> 而后面两个函数大概作用就是，将回调函数返回值赋给新的Promise，就不再多说</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;最近看的一些零碎片段&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Sundries" scheme="http://yoursite.com/categories/Sundries/"/>
    
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>复仇者联盟3：无限战争</title>
    <link href="http://yoursite.com/2018/05/12/marvelAvengers/"/>
    <id>http://yoursite.com/2018/05/12/marvelAvengers/</id>
    <published>2018-05-11T16:39:06.000Z</published>
    <updated>2018-09-26T08:26:26.441Z</updated>
    
    <content type="html"><![CDATA[<p><strong>漫威十年</strong><br><a id="more"></a><br>跟朋友看了复联三的首映，特效还是漫威制造，只是编剧智商是不在线么，瓦坎达作为地球上科技文明最发达的地区，打外星狗还都是肉搏的，一顿激光乱扫不就完事儿了。还有寡姐竟然能跟暗夜比邻星打的有来有回？？黑曜五将变得这么不值钱了？？？<br>最后说一句，锤哥牛逼。</p><p><img src="/images/thor.jpg" alt="&quot;锤哥&quot;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;漫威十年&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Sundries" scheme="http://yoursite.com/categories/Sundries/"/>
    
    
      <category term="marvel" scheme="http://yoursite.com/tags/marvel/"/>
    
  </entry>
  
  <entry>
    <title>だざい おさむ</title>
    <link href="http://yoursite.com/2018/04/11/tzz/"/>
    <id>http://yoursite.com/2018/04/11/tzz/</id>
    <published>2018-04-11T13:03:55.000Z</published>
    <updated>2018-09-27T02:53:56.822Z</updated>
    
    <content type="html"><![CDATA[<p>日々のちょっとした喜（よろこ）びを大切（たいせつ）にし、足元（あしもと）<a id="more"></a>の現実（げんじつ）を少しずつ積（つ）み重（かさ）ねていくことが、明るい未来（みらい）につながっていくんだと思います。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日々のちょっとした喜（よろこ）びを大切（たいせつ）にし、足元（あしもと）
    
    </summary>
    
      <category term="Sundries" scheme="http://yoursite.com/categories/Sundries/"/>
    
    
  </entry>
  
  <entry>
    <title>工具提示框位置判断</title>
    <link href="http://yoursite.com/2018/02/15/tooltipsplacement/"/>
    <id>http://yoursite.com/2018/02/15/tooltipsplacement/</id>
    <published>2018-02-15T13:56:01.000Z</published>
    <updated>2018-09-26T08:26:44.584Z</updated>
    
    <content type="html"><![CDATA[<p><strong>提示框展示位置计算</strong><br><a id="more"></a><br>最近做了一个工具提示框，提示框的位置开放了标准的十二个，在这里把相对定位left与top的计算放一哈。</p><h2 id="tooltips位置判断，this-placement为位置参数"><a href="#tooltips位置判断，this-placement为位置参数" class="headerlink" title="tooltips位置判断，this.placement为位置参数"></a>tooltips位置判断，this.placement为位置参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.placement) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'top'</span> :</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft - popover.offsetWidth / <span class="number">2</span> + trigger.offsetWidth / <span class="number">2</span></span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop - popover.offsetHeight</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'top-start'</span> :</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft</span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop - popover.offsetHeight</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'top-end'</span> :</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft + trigger.offsetWidth - popover.offsetWidth</span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop - popover.offsetHeight</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'left'</span>:</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft - popover.offsetWidth</span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop + trigger.offsetHeight / <span class="number">2</span> - popover.offsetHeight / <span class="number">2</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'left-start'</span>:</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft - popover.offsetWidth</span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'left-end'</span>:</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft - popover.offsetWidth</span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop + trigger.offsetHeight - popover.offsetHeight</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'right'</span>:</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft + trigger.offsetWidth</span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop + trigger.offsetHeight / <span class="number">2</span> - popover.offsetHeight / <span class="number">2</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'right-start'</span>:</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft + trigger.offsetWidth</span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'right-end'</span>:</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft + trigger.offsetWidth</span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop + trigger.offsetHeight - popover.offsetHeight</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'bottom'</span>:</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft - popover.offsetWidth / <span class="number">2</span> + trigger.offsetWidth / <span class="number">2</span></span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop + trigger.offsetHeight</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'bottom-start'</span>:</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft</span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop + trigger.offsetHeight</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'bottom-end'</span>:</span><br><span class="line">        <span class="keyword">this</span>.position.left = trigger.offsetLeft + trigger.offsetWidth - popover.offsetWidth</span><br><span class="line">        <span class="keyword">this</span>.position.top = trigger.offsetTop + trigger.offsetHeight</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Wrong placement prop'</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="附上盒模型的示例图"><a href="#附上盒模型的示例图" class="headerlink" title="附上盒模型的示例图"></a>附上盒模型的示例图</h3><h2 id><a href="#" class="headerlink" title></a><img src="/images/place.png" alt="&quot;placement示例&quot;"></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;提示框展示位置计算&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Sundries" scheme="http://yoursite.com/categories/Sundries/"/>
    
    
      <category term="tool" scheme="http://yoursite.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>在ES6 + Angular1.x的标准下，改造iView组件</title>
    <link href="http://yoursite.com/2018/02/11/iviewToAngular/"/>
    <id>http://yoursite.com/2018/02/11/iviewToAngular/</id>
    <published>2018-02-11T06:03:23.000Z</published>
    <updated>2018-09-26T08:24:44.761Z</updated>
    
    <content type="html"><![CDATA[<p><strong>偶尔吐槽下</strong></p><p></p><p align="right"><em>——swag</em></p><br><a id="more"></a><br>先交代故事背景，前端项目架构webpack + angular1.x + 自iview改造的组件 + ES6 + ESlint。<br>这个斑驳的组合也造就了下面的问题，iview是基于vue.js的组件库，但是我们不走寻常路，要把它用在angular1.x版本的项目当中去（可能因为好看吧，不要问我为什么不用antdesign…）。<br>来说问题，像iview开发中用到的自带@after-leave（过渡结束后调用）之类的事件钩子在angular中是很难实现的，ng-animate可以么？可以是可以，但是ng-animate是针对所有标签来增加/隐藏 class来增加动画效果，达不到我对点对于单一组件的要求。<br>怎么解决呢，angular控制显影用到的是ng-show，我们用一个变量isShow来判断是否展示，然后对这个isShow字段进行$watch监听，初始不展示状态下isShow值为undefined或false，这时候我们就可以载监听事件中进行判断了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">scope.$watch(&apos;isShow&apos;, function(newValue, oldValue) &#123;</span><br><span class="line">      if ((newValue === undefined &amp;&amp; oldValue === undefined) || (newValue === false &amp;&amp; oldValue === false)) &#123;</span><br><span class="line">        // 初始化</span><br><span class="line">        scope.wrapClasses = () =&gt; &#123;</span><br><span class="line">          return [</span><br><span class="line">            `$&#123;prefixCls&#125;-wrap`,</span><br><span class="line">            &#123;</span><br><span class="line">              [`$&#123;prefixCls&#125;-hidden`]: true,</span><br><span class="line">              [`$&#123;scope.className&#125;`]: !!scope.className</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (newValue === true) &#123;</span><br><span class="line">        // 出现</span><br><span class="line">        scope.wrapClasses = () =&gt; &#123;</span><br><span class="line">          return [</span><br><span class="line">            `$&#123;prefixCls&#125;-wrap`,</span><br><span class="line">            &#123;</span><br><span class="line">              [`$&#123;prefixCls&#125;-hidden`]: false,</span><br><span class="line">              [`$&#123;scope.className&#125;`]: !!scope.className</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (newValue === false &amp;&amp; oldValue === true) &#123;</span><br><span class="line">        $timeout(function() &#123;</span><br><span class="line">          // &apos;消失</span><br><span class="line">          scope.wrapClasses = () =&gt; &#123;</span><br><span class="line">            return [</span><br><span class="line">              `$&#123;prefixCls&#125;-wrap`,</span><br><span class="line">              &#123;</span><br><span class="line">                [`$&#123;prefixCls&#125;-hidden`]: true,</span><br><span class="line">                [`$&#123;scope.className&#125;`]: !!scope.className</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 450)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化的newValue和oldValue应为undefined或false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if ((newValue === undefined &amp;&amp; oldValue === undefined) || (newValue === false &amp;&amp; oldValue === false)) &#123;</span><br><span class="line">        // 初始化</span><br><span class="line">        scope.wrapClasses = () =&gt; &#123;</span><br><span class="line">          return [</span><br><span class="line">            `$&#123;prefixCls&#125;-wrap`,</span><br><span class="line">            &#123;</span><br><span class="line">              [`$&#123;prefixCls&#125;-hidden`]: true,</span><br><span class="line">              [`$&#123;scope.className&#125;`]: !!scope.className</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>展示的时候意味着isShow的值为true，那就是newValue为true进入展示判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (newValue === true) &#123;</span><br><span class="line">        // 出现</span><br><span class="line">        scope.wrapClasses = () =&gt; &#123;</span><br><span class="line">          return [</span><br><span class="line">            `$&#123;prefixCls&#125;-wrap`,</span><br><span class="line">            &#123;</span><br><span class="line">              [`$&#123;prefixCls&#125;-hidden`]: false,</span><br><span class="line">              [`$&#123;scope.className&#125;`]: !!scope.className</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>隐藏的情况与展示类似，只不过多一个oldValue的判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (newValue === false &amp;&amp; oldValue === true) &#123;</span><br><span class="line">        $timeout(function() &#123;</span><br><span class="line">          // &apos;消失</span><br><span class="line">          scope.wrapClasses = () =&gt; &#123;</span><br><span class="line">            return [</span><br><span class="line">              `$&#123;prefixCls&#125;-wrap`,</span><br><span class="line">              &#123;</span><br><span class="line">                [`$&#123;prefixCls&#125;-hidden`]: true,</span><br><span class="line">                [`$&#123;scope.className&#125;`]: !!scope.className</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 450)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>这里我用了$timeout做了一个延时处理，主要作用是延迟“[<code>${prefixCls}-hidden</code>]”该类（false-&gt;true）的触发，从而达到我们自定义animation的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;偶尔吐槽下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;&lt;em&gt;——swag&lt;/em&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Sundries" scheme="http://yoursite.com/categories/Sundries/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
      <category term="iview" scheme="http://yoursite.com/tags/iview/"/>
    
  </entry>
  
  <entry>
    <title>arrow function</title>
    <link href="http://yoursite.com/2017/10/18/arrowFunction/"/>
    <id>http://yoursite.com/2017/10/18/arrowFunction/</id>
    <published>2017-10-18T13:03:55.000Z</published>
    <updated>2018-09-26T08:12:48.458Z</updated>
    
    <content type="html"><![CDATA[<p><strong>箭头函数学习笔记</strong><br><a id="more"></a></p><ul><li><p>下面的代码段，我们用一个参数，返回了一个结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map( <span class="function"><span class="params">num</span>=&gt;</span> num * <span class="number">2</span> )</span><br><span class="line"><span class="comment">// &lt;- [2,4,6]</span></span><br><span class="line"></span><br><span class="line">用es5表示</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123; <span class="keyword">return</span> num * <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;- [2, 4, 6]</span></span><br></pre></td></tr></table></figure></li><li><p>如果我们需要用到更多的参数，或者不用参数，那么我们需要圆括号将参数包裹起来.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function">(<span class="params"> num,index </span>) =&gt;</span> num*<span class="number">2</span>+index )</span><br><span class="line"><span class="comment">//&lt;-[2,5,8,11]</span></span><br></pre></td></tr></table></figure></li><li><p>当需要其他代码块，并且只返回一个表达式时我们需要中括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> multiplier = <span class="number">2</span> + num;</span><br><span class="line">    <span class="keyword">return</span> num * multiplier</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- [3, 8, 15, 24]</span></span><br></pre></td></tr></table></figure></li><li><p>当你运用插入语法时，你也可以添加更多参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function">(<span class="params">num, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> multiplier = <span class="number">2</span> + index</span><br><span class="line">  <span class="keyword">return</span> num * multiplier</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- [2, 6, 12, 20]</span></span><br></pre></td></tr></table></figure></li><li><p>当我们需要返回一个对象的时候我们需要把表达式包裹在大括号中,只有这样才不会被解析成代码块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">n</span> =&gt;</span> &#123; <span class="attr">number</span>: n &#125;)</span><br><span class="line"><span class="comment">// [undefined, undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">n</span> =&gt;</span> &#123; <span class="attr">number</span>: n, <span class="attr">something</span>: <span class="string">'else'</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;- SyntaxError</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">n</span> =&gt;</span> (&#123; <span class="attr">number</span>: n &#125;))</span><br><span class="line"><span class="comment">// &lt;- [&#123; number: 1 &#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">n</span> =&gt;</span> (&#123; <span class="attr">number</span>: n, <span class="attr">something</span>: <span class="string">'else'</span> &#125;))</span><br><span class="line"><span class="comment">/* &lt;- [</span></span><br><span class="line"><span class="comment">  &#123; number: 1, something: 'else' &#125;,</span></span><br><span class="line"><span class="comment">  &#123; number: 2, something: 'else' &#125;,</span></span><br><span class="line"><span class="comment">  &#123; number: 3, something: 'else' &#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>一个很酷的属性是箭头函数绑定了this上下文的属性</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.seconds = <span class="number">0</span></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.seconds++, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer()</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(timer.seconds), <span class="number">3100</span>)</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;箭头函数学习笔记&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Sundries" scheme="http://yoursite.com/categories/Sundries/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>setState 同步更新</title>
    <link href="http://yoursite.com/2017/03/22/reactSetstate/"/>
    <id>http://yoursite.com/2017/03/22/reactSetstate/</id>
    <published>2017-03-22T14:30:16.000Z</published>
    <updated>2018-09-26T08:26:44.544Z</updated>
    
    <content type="html"><![CDATA[<p><strong>React中setState同步更新解决方案</strong><br><a id="more"></a></p><h2 id="setState-同步更新"><a href="#setState-同步更新" class="headerlink" title="setState 同步更新"></a>setState 同步更新</h2><p>最近遇到个问题，对于较大数据量的下载前端需要做进度条的提示给用户，思路是我需要从服务端抓取数据并且渲染到界面之后，再隐藏加载进度条或者外部加载提示。<br>但。。。。<br>React为了提高渲染性能，将setState设置为批次更新（异步操作函数），但是不能以顺序控制流的方式设置某些事件，也不能依赖于this.state来计算未来状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    fetch(&apos;https://example.com&apos;)</span><br><span class="line">        .then((res) =&gt; res.json())</span><br><span class="line">        .then(</span><br><span class="line">            (something) =&gt; &#123;</span><br><span class="line">                this.setState(&#123; something &#125;);</span><br><span class="line">                StatusBar.setNetworkActivityIndicatorVisible(false);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为setState函数并不会阻塞等待状态更新完毕，因此setNetworkActivityIndicatorVisible有可能先于数据渲染完毕就执行。我可以选择在componentWillUpdate与componentDidUpdate这两个生命周期的回调函数中执行setNetworkActivityIndicatorVisible，但是会让代码变得破碎，可读性也不好。实际上在项目开发中我更频繁遇见此类问题的场景是以某个变量控制元素可见性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;showForm : !this.state.showForm&#125;);</span><br></pre></td></tr></table></figure></p><p>我预期的效果是每次事件触发后改变表单的可见性，但是在大型应用程序中如果事件的触发速度快于setState的更新速度，那么我的值计算完全就是错的。本节就是讨论两种方式来保证setState的同步更新。</p><h2 id="完成回调"><a href="#完成回调" class="headerlink" title="完成回调"></a>完成回调</h2><p>setState函数的第二个参数允许传入回调函数，在状态更新完毕后进行调用，譬如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">      load: !this.state.load,</span><br><span class="line">      count: this.state.count + 1</span><br><span class="line">    &#125;, () =&gt; &#123;</span><br><span class="line">      console.log(this.state.count);</span><br><span class="line">      console.log(&apos;加载完成&apos;)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>这里的回调函数用法相信大家很熟悉，就是JavaScript异步编程相关知识，我可以引入Promise来封装setState:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setStateAsync(state) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; &#123;</span><br><span class="line">    this.setState(state, resolve)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>setStateAsync 返回的是Promise对象，在调用时我可以使用Async/Await语法来优化代码风格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async componentDidMount() &#123;</span><br><span class="line">    StatusBar.setNetworkActivityIndicatorVisible(true)</span><br><span class="line">    const res = await fetch(&apos;https://api.ipify.org?format=json&apos;)</span><br><span class="line">    const &#123;ip&#125; = await res.json()</span><br><span class="line">    await this.setStateAsync(&#123;ipAddress: ip&#125;)</span><br><span class="line">    StatusBar.setNetworkActivityIndicatorVisible(false)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这里我就可以保证在setState渲染完毕之后调用外部状态栏将网络请求状态修改为已结束，整个组件的完整定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class AwesomeProject extends Component &#123;</span><br><span class="line">  state = &#123;&#125;</span><br><span class="line">  setStateAsync(state) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  async componentDidMount() &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class="line">          My IP is &#123;this.state.ipAddress || &apos;Unknown&apos;&#125;</span><br><span class="line">        &lt;/Text&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="传入状态计算函数"><a href="#传入状态计算函数" class="headerlink" title="传入状态计算函数"></a>传入状态计算函数</h2><p>除了使用回调函数的方式监听状态更新结果之外，React还允许我传入某个状态计算函数而不是对象来作为第一个参数。状态计算函数能够为我提供可信赖的组件的State与Props值，即会自动地将我的状态更新操作添加到队列中并等待前面的更新完毕后传入最新的状态值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(function(prevState, props)&#123;</span><br><span class="line">   return &#123;showForm: !prevState.showForm&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里我以简单的计数器为例，我希望用户点击按钮之后将计数值连加两次，基本的组件为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Counter extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;count : 0&#125;</span><br><span class="line">    this.incrementCount = this.incrementCount.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  incrementCount()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">              &lt;button onClick=&#123;this.incrementCount&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line">              &lt;div&gt;&#123;this.state.count&#125;&lt;/div&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直观的写法我可以连续调用两次setState函数，这边的用法可能看起来有点怪异，不过更多的是为了说明异步更新带来的数据不可预测问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">incrementCount()&#123;</span><br><span class="line">   this.setState(&#123;count : this.state.count + 1&#125;)</span><br><span class="line">   this.setState(&#123;count : this.state.count + 1&#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>上述代码的效果是每次点击之后计数值只会加1，实际上第二个setState并没有等待第一个setState执行完毕就开始执行了，因此其依赖的当前计数值完全是错的。我当然可以使用上文提及的setStateAsync来进行同步控制，不过这里我使用状态计算函数来保证同步性：（这里的第二个setState传入的prevState值就是第一个setState执行完毕之后的计数值，也顺利保证了连续自增两次。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">incrementCount()&#123;</span><br><span class="line">   this.setState((prevState, props) =&gt; (&#123;</span><br><span class="line">      count: prevState.count + 1</span><br><span class="line">    &#125;));</span><br><span class="line">   this.setState((prevState, props) =&gt; (&#123;</span><br><span class="line">      count: prevState.count + 1</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;React中setState同步更新解决方案&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>cookie</title>
    <link href="http://yoursite.com/2015/12/11/cookie/"/>
    <id>http://yoursite.com/2015/12/11/cookie/</id>
    <published>2015-12-11T05:08:41.000Z</published>
    <updated>2018-10-22T07:24:35.186Z</updated>
    
    <content type="html"><![CDATA[<p><strong>cookie</strong><br><a id="more"></a><br>—–18/10/22更新—–<br>昨儿用cookie参数做了一个初始进入系统弹框再次刷新页面弹框不展示的需求，用户登出需要remove掉这个参数，但是写完之后发现用户正常登出之后再次登录弹框就不展示了，排查了会儿发现还是cookie的path问题。<br>在登录之后给参数isFirst赋值的时候第一条是我开始写的跟下面的第二条相比少了个{path: ‘/‘}，因为第一条我没加这个路径，所以系统会给isFirst默认加上/xxx的路径导致logout的时候remove不掉。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cookies.put(<span class="string">'isFirst'</span>, <span class="literal">true</span>)</span><br><span class="line">$cookies.put(<span class="string">'isFirst'</span>, <span class="literal">true</span>, &#123;<span class="attr">path</span>: <span class="string">'/'</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>注：删除的时候path路径也要相同。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cookies.remove(<span class="string">'isFirst'</span>, &#123;<span class="attr">path</span>: <span class="string">'/'</span>&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="/images/cookie.png" alt="&quot;cookie在chrome上的查看&quot;"><br>我们可以在chrome上的Application查看当前cookie的路径是什么，很直观。</p><h3 id="引：关于cookie的解析"><a href="#引：关于cookie的解析" class="headerlink" title="引：关于cookie的解析"></a><a href="http://www.cnblogs.com/Darren_code/archive/2011/11/24/Cookie.html" target="_blank" rel="noopener">引：关于cookie的解析</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;cookie&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Sundries" scheme="http://yoursite.com/categories/Sundries/"/>
    
    
      <category term="cookie" scheme="http://yoursite.com/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>sublime快捷键保存（个人）</title>
    <link href="http://yoursite.com/2015/08/23/sublimekey/"/>
    <id>http://yoursite.com/2015/08/23/sublimekey/</id>
    <published>2015-08-23T02:27:57.000Z</published>
    <updated>2018-09-26T08:26:44.514Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人自适应快捷键，Alt+2 = 开启分屏，Alt+1 = 关闭分屏，Alt+H = 搜索替换</strong><br><a id="more"></a><br><strong>ctrl+shift+p -&gt; key bindings -User</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line"><span class="string">"keys"</span>: [<span class="string">"alt+q"</span>],</span><br><span class="line"><span class="string">"command"</span>: <span class="string">"run_macro_file"</span>,</span><br><span class="line"><span class="string">"args"</span>: &#123;</span><br><span class="line"><span class="string">"file"</span>: <span class="string">"res://Packages/Default/Delete Line.sublime-macro"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"keys"</span>: [<span class="string">"alt+h"</span>],</span><br><span class="line"><span class="string">"command"</span>: <span class="string">"show_panel"</span>,</span><br><span class="line"><span class="string">"args"</span>: &#123;</span><br><span class="line"><span class="string">"panel"</span>: <span class="string">"find_in_files"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"keys"</span>: [<span class="string">"alt+1"</span>],</span><br><span class="line"><span class="string">"command"</span>: <span class="string">"set_layout"</span>,</span><br><span class="line"><span class="string">"args"</span>: &#123;</span><br><span class="line"><span class="string">"cols"</span>: [<span class="number">0.0</span>, <span class="number">1.0</span>],</span><br><span class="line"><span class="string">"rows"</span>: [<span class="number">0.0</span>, <span class="number">1.0</span>],</span><br><span class="line"><span class="string">"cells"</span>: [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"keys"</span>: [<span class="string">"alt+2"</span>],</span><br><span class="line"><span class="string">"command"</span>: <span class="string">"set_layout"</span>,</span><br><span class="line"><span class="string">"args"</span>: &#123;</span><br><span class="line"><span class="string">"cols"</span>: [<span class="number">0.0</span>, <span class="number">0.77</span>, <span class="number">1.0</span>],</span><br><span class="line"><span class="string">"rows"</span>: [<span class="number">0.0</span>, <span class="number">1.0</span>],</span><br><span class="line"><span class="string">"cells"</span>: [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"keys"</span>: [<span class="string">"ctrl+6"</span>],</span><br><span class="line"><span class="string">"command"</span>: <span class="string">"css_comb"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"keys"</span>: [<span class="string">"alt+d"</span>],</span><br><span class="line"><span class="string">"command"</span>: <span class="string">"close"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"keys"</span>: [<span class="string">"alt+a"</span>],</span><br><span class="line"><span class="string">"command"</span>: <span class="string">"toggle_side_bar"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"keys"</span>: [<span class="string">"ctrl+shift+r"</span>],</span><br><span class="line"><span class="string">"command"</span>: <span class="string">"reindent"</span>,</span><br><span class="line"><span class="string">"args"</span>: &#123;</span><br><span class="line"><span class="string">"single_line"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人自适应快捷键，Alt+2 = 开启分屏，Alt+1 = 关闭分屏，Alt+H = 搜索替换&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Sundries" scheme="http://yoursite.com/categories/Sundries/"/>
    
    
      <category term="tool" scheme="http://yoursite.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>localStorage &amp; sessionStorage</title>
    <link href="http://yoursite.com/2015/05/26/localStorage/"/>
    <id>http://yoursite.com/2015/05/26/localStorage/</id>
    <published>2015-05-26T14:33:43.000Z</published>
    <updated>2018-09-26T08:25:44.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="localStorage与sessionStorage的比较"><a href="#localStorage与sessionStorage的比较" class="headerlink" title="localStorage与sessionStorage的比较"></a>localStorage与sessionStorage的比较</h3><a id="more"></a><h2 id="localStorage-介绍"><a href="#localStorage-介绍" class="headerlink" title="localStorage 介绍"></a>localStorage 介绍</h2><p>在HTML5中，引入了两个新的前端存储特性：</p><ul><li>localStorage</li><li>sessionStorage</li></ul><p>这两者非常相似，都是用来在前端保存一定量的数据，称为前端存储，但是这两者仍然存在一定区别：</p><ul><li>生命周期：<ul><li>localStorage:localStorage的生命周期是永久的，即使关闭页面、浏览器，其中的内容也不会消失，除非手动删除localStorage中的内容</li><li>sessionStorage:sessionStorage的生命周期是一次浏览器窗口会话，浏览器窗口指的是一组同源页面(来自于一个域名)的浏览器页面集合，当这些窗口全部关闭之后，sessionStorage的内容将不会存在</li></ul></li><li>存储大小：<ul><li>两者都为5MB/域名</li></ul></li><li>存储位置：<ul><li>两者都保存在客户端，不与服务器进行交互</li></ul></li><li>存储内容类型：<ul><li>两者都只能存储字符串，但是可以通过类型转换来存储各类数据</li></ul></li><li>获取方式：<ul><li>localStorage: window.localStorage</li><li>sessionStorage: sessionStorage</li></ul></li></ul><p>可见localStorage适合在前端存储长时间使用的数据， 而sessionStorage适合存储短期使用、一次性的数据</p><p>另外这里要提一句，sessionStorage并不是session：</p><ul><li>sessionStorage中的‘session’是指浏览器窗口会话，而后者的‘session’指的是服务器会话</li><li>前者是前端存储，与服务器无关，而后者的实现依赖于服务器</li></ul><p>这里只介绍更加常用的localStorage的使用，而sessionStorage的使用其实也类似</p><h2 id="localStorage的使用"><a href="#localStorage的使用" class="headerlink" title="localStorage的使用"></a>localStorage的使用</h2><p>localStorage作为一个在HTML5中引入的特性，在IE6/7等一些低版本的浏览器中是无法被支持的，所以建议在使用localStorage之前先检查浏览器支持情况：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.localStorage) &#123;</span><br><span class="line">    <span class="comment">// 当浏览器不支持 localStorage ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 浏览器支持 localStorage ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>存储在localStorage中的数据一定是以字符串形式存在的，所以当你存入/读取其他形式的数据时，需要进行类型转换才行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存入 json 数据</span></span><br><span class="line">localStorage.jsonTest = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: <span class="string">'zero'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 json 数据</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(localStorage.jsonTest).a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(localStorage.jsonTest).b);</span><br></pre></td></tr></table></figure></p><h2 id="sessionStorage的使用"><a href="#sessionStorage的使用" class="headerlink" title="sessionStorage的使用"></a>sessionStorage的使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到sessionStorage</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从sessionStorage获取数据</span></span><br><span class="line"><span class="keyword">var</span> data = sessionStorage.getItem(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从sessionStorage删除保存的数据</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从sessionStorage删除所有保存的数据</span></span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;localStorage与sessionStorage的比较&quot;&gt;&lt;a href=&quot;#localStorage与sessionStorage的比较&quot; class=&quot;headerlink&quot; title=&quot;localStorage与sessionStorage的比较&quot;&gt;&lt;/a&gt;localStorage与sessionStorage的比较&lt;/h3&gt;
    
    </summary>
    
      <category term="Sundries" scheme="http://yoursite.com/categories/Sundries/"/>
    
    
      <category term="localStorage" scheme="http://yoursite.com/tags/localStorage/"/>
    
      <category term="sessionStorage" scheme="http://yoursite.com/tags/sessionStorage/"/>
    
  </entry>
  
  <entry>
    <title>如今的我【置顶】</title>
    <link href="http://yoursite.com/2015/05/16/initial/"/>
    <id>http://yoursite.com/2015/05/16/initial/</id>
    <published>2015-05-16T14:48:30.000Z</published>
    <updated>2018-09-27T01:57:10.009Z</updated>
    
    <content type="html"><![CDATA[<p><strong>唯有尽力自持，方不致癫狂</strong></p><p align="right"><em>——太宰治 《人间失格》</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;唯有尽力自持，方不致癫狂&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;em&gt;——太宰治 《人间失格》&lt;/em&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Sundries" scheme="http://yoursite.com/categories/Sundries/"/>
    
    
      <category term="无病呻吟" scheme="http://yoursite.com/tags/%E6%97%A0%E7%97%85%E5%91%BB%E5%90%9F/"/>
    
  </entry>
  
</feed>
